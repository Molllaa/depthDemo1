{"version":3,"sources":["inference.worker.js","utils.js","App.js","index.js"],"names":["addMethods","methods","module","exports","w","Worker","name","deserializeTensor","data","shape","tf","WebGLViewer","inputImage","depthMapImage","viewMode","mousePosition","orientation","parallaxStrength","focus","zoom","canvasRef","useRef","rendererRef","sceneRef","cameraRef","materialRef","imageTextureRef","depthTextureRef","planeMeshRef","handleResize","useCallback","current","parentElement","newWidth","clientWidth","newHeight","clientHeight","setSize","aspect","updateProjectionMatrix","scale","imageAspect","image","width","height","fov","cameraZ","position","z","containerAspect","visibleHeight","Math","tan","THREE","degToRad","set","useEffect","canvas","renderer","antialias","setPixelRatio","window","devicePixelRatio","scene","camera","material","vertexShader","fragmentShader","uniforms","u_image","value","mouseDelta","meshDepth","sensitivity","animate","requestAnimationFrame","render","addEventListener","removeEventListener","dispose","load","texture","remove","geometry","img","Image","src","onload","document","createElement","ctx","getContext","drawImage","depthData","vertices","attributes","array","depths","Float32Array","length","i","vertexIndex","u","uv","v","x","floor","pixelIndex","depthValue","setAttribute","needsUpdate","createGeometryFromDepthMap","getImageData","mesh","add","targetX","targetY","y","gamma","beta","currentDelta","ref","className","App","inferenceWorkerRef","useState","inputSource","setInputSource","depthMapSource","setDepthMapSource","isDepthMapReady","setIsDepthMapReady","inputRef","outputRef","processing","setProcessing","test","navigator","userAgent","setViewMode","mousePositionForShader","setMousePositionForShader","orientationForShader","setOrientationForShader","webGLContainerRef","isGyroAvailable","setIsGyroAvailable","setParallaxStrength","setFocus","isDrawerOpen","setIsDrawerOpen","setZoom","startX","setStartX","InferenceWorker","DeviceOrientationEvent","handleDeviceOrientation","event","alpha","inferCallback","a","console","error","alert","clearRect","input","fromPixels","originalSize","modelName","getElementById","inputSize","slice","resizeBilinear","log","inputSerialized","tensor","dataSync","infer","outputTensor","toPixels","tempCanvas","clone","toDataURL","onDrop","acceptedFiles","fr","FileReader","result","readAsDataURL","useDropzone","accept","getRootProps","getInputProps","isDragActive","handleMouseMoveInViewer","rect","getBoundingClientRect","clientX","touches","clientY","left","top","max","min","toggleDrawer","onClick","onTouchStart","e","onTouchMove","htmlFor","id","onChange","switchModel","target","style","color","toFixed","type","step","parseFloat","stopPropagation","join","alt","onLoad","disabled","onMouseMove","ReactDOM","StrictMode"],"mappings":"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","file":"static/js/main.652345c3.chunk.js","sourcesContent":["\n\t\t\t\tvar addMethods = require(\"../node_modules/workerize-loader/dist/rpc-wrapper.js\")\n\t\t\t\tvar methods = [\"switchModel\",\"infer\"]\n\t\t\t\tmodule.exports = function() {\n\t\t\t\t\tvar w = new Worker(__webpack_public_path__ + \"4f49c28c5549ba7b2fbb.worker.js\", { name: \"[hash].worker.js\" })\n\t\t\t\t\taddMethods(w, methods)\n\t\t\t\t\t\n\t\t\t\t\treturn w\n\t\t\t\t}\n\t\t\t","import * as tf from \"@tensorflow/tfjs\";\n\nexport const serializeTensor = (tensor) => ({\n  data: tensor.dataSync(),\n  shape: tensor.shape,\n});\nexport const deserializeTensor = ({ data, shape }) => tf.tensor(data, shape);\n","/* eslint import/no-webpack-loader-syntax: off */\nimport \"./App.css\";\nimport { useCallback, useRef, useState, useEffect } from \"react\"; // useMemo removed as it's replaced by useEffect/useRef pattern\nimport { useDropzone } from \"react-dropzone\";\nimport * as tf from \"@tensorflow/tfjs\";\nimport InferenceWorker from \"workerize-loader!./inference.worker\";\nimport { serializeTensor, deserializeTensor } from \"./utils\";\n\nimport * as THREE from 'three'; // Assuming THREE is installed or will be\n\n// Basic Shader code (simplified, to be adapted from tiefling/shader.js)\nconst vertexShader = `\n  attribute float depth;\n  varying vec2 vUv;\n  uniform vec2 mouseDelta;\n  uniform float focus;\n  uniform float meshDepth;\n  uniform float sensitivity;\n\n  void main() {\n    vUv = uv;\n    vec3 pos = position;\n\n    float actualDepth = depth * meshDepth;\n    float focusDepth = focus * meshDepth;\n\n    // Rotational displacement (relative to focus depth)\n    vec2 rotate = mouseDelta * sensitivity * \n        (1.0 - focus) * \n        (actualDepth - focusDepth) * \n        vec2(-1.0, 1.0);\n\n    // Calculate edge proximity factor (0 at edges, 1 in center)\n    float edgeWidth = 0.01; // controls edge stiffness\n    vec2 edgeFactorVec = smoothstep(0.0, edgeWidth, vUv) * \n                        smoothstep(1.0, 1.0 - edgeWidth, vUv);\n    float edgeFactor = edgeFactorVec.x * edgeFactorVec.y;\n\n    // Apply displacement with edge preservation\n    pos.xy += rotate * edgeFactor;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n  }\n`;\n\nconst fragmentShader = `\n  uniform sampler2D u_image;\n  varying vec2 vUv;\n\n  void main() {\n    gl_FragColor = texture2D(u_image, vUv);\n  }\n`;\n\nconst WebGLViewer = ({ inputImage, depthMapImage, viewMode, mousePosition, orientation, parallaxStrength, focus, zoom }) => {\n  const canvasRef = useRef(null);\n  const rendererRef = useRef(null);\n  const sceneRef = useRef(null);\n  const cameraRef = useRef(null);\n  const materialRef = useRef(null);\n  const imageTextureRef = useRef(null);\n  const depthTextureRef = useRef(null);\n  const planeMeshRef = useRef(null);\n\n  const handleResize = useCallback(() => {\n    if (canvasRef.current && rendererRef.current && cameraRef.current && canvasRef.current.parentElement) {\n        const parentElement = canvasRef.current.parentElement;\n        const newWidth = parentElement.clientWidth;\n        const newHeight = parentElement.clientHeight;\n        rendererRef.current.setSize(newWidth, newHeight);\n        cameraRef.current.aspect = newWidth / newHeight;\n        cameraRef.current.updateProjectionMatrix();\n\n        // Recalculate mesh scale if planeMeshRef.current exists\n        if (planeMeshRef.current && imageTextureRef.current) {\n            const imageAspect = imageTextureRef.current.image.width / imageTextureRef.current.image.height;\n            const fov = cameraRef.current.fov;\n            const cameraZ = cameraRef.current.position.z;\n            const containerAspect = newWidth / newHeight;\n            const visibleHeight = 2 * Math.tan(THREE.MathUtils.degToRad(fov / 2)) * cameraZ;\n            const visibleWidth = visibleHeight * containerAspect;\n\n            let scale;\n            if (containerAspect > imageAspect) {\n                scale = visibleHeight / 1; // Geometry height is 1\n            } else {\n                scale = visibleWidth / imageAspect; // Geometry width is imageAspect\n            }\n            planeMeshRef.current.scale.set(scale, scale, 1);\n        }\n    }\n  }, []);\n\n  useEffect(() => {\n    // Initialize THREE.js scene\n    const canvas = canvasRef.current;\n    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });\n    renderer.setSize(canvas.clientWidth, canvas.clientHeight);\n    renderer.setPixelRatio(window.devicePixelRatio);\n    rendererRef.current = renderer;\n\n    const scene = new THREE.Scene();\n    sceneRef.current = scene;\n\n    const fov = 45;\n    const camera = new THREE.PerspectiveCamera(fov, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);\n    camera.position.z = 2;\n    cameraRef.current = camera;\n\n    const geometry = new THREE.PlaneGeometry(1, 1);\n    const material = new THREE.ShaderMaterial({\n      vertexShader,\n      fragmentShader,\n      uniforms: {\n        u_image: { value: null },\n        mouseDelta: { value: new THREE.Vector2(0, 0) },\n        focus: { value: focus },\n        meshDepth: { value: 1.0 },\n        sensitivity: { value: 0.5 }\n      },\n    });\n    materialRef.current = material;\n\n    // Plane will be created and added when depth map is ready\n    // const plane = new THREE.Mesh(geometry, material);\n    // scene.add(plane);\n\n    const animate = () => {\n      requestAnimationFrame(animate);\n      renderer.render(scene, camera);\n    };\n    animate();\n\n    window.addEventListener('resize', handleResize);\n    handleResize();\n\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      if (rendererRef.current) rendererRef.current.dispose();\n      if(imageTextureRef.current) imageTextureRef.current.dispose(); // Dispose textures on unmount\n      if(depthTextureRef.current) depthTextureRef.current.dispose(); // Dispose textures on unmount\n      // geometry.dispose(); material.dispose(); // If created here\n    };\n  }, [handleResize]);\n\n  useEffect(() => {\n    if (materialRef.current && inputImage) {\n      if (imageTextureRef.current) imageTextureRef.current.dispose();\n      const loader = new THREE.TextureLoader();\n      loader.load(inputImage, (texture) => {\n        imageTextureRef.current = texture;\n        materialRef.current.uniforms.u_image.value = texture;\n        // Resize logic will be handled when the mesh is created/updated\n      });\n    }\n  }, [inputImage]);\n\n  const createGeometryFromDepthMap = (depthData) => {\n    const width = depthData.width;\n    const height = depthData.height;\n    const imageAspect = width / height;\n    const geometry = new THREE.PlaneGeometry(imageAspect, 1, width - 1, height - 1);\n    const vertices = geometry.attributes.position.array;\n    const depths = new Float32Array(vertices.length / 3);\n\n    for (let i = 0; i < vertices.length; i += 3) {\n        const vertexIndex = i / 3;\n        const u = geometry.attributes.uv.array[vertexIndex * 2];\n        const v = 1.0 - geometry.attributes.uv.array[vertexIndex * 2 + 1];\n        const x = Math.floor(u * (width - 1));\n        const y = Math.floor(v * (height - 1));\n        const pixelIndex = (y * width + x) * 4;\n        const depthValue = depthData.data[pixelIndex] / 255.0;\n\n        vertices[i + 2] = depthValue; // Set z based on depth\n        depths[vertexIndex] = depthValue;\n    }\n\n    geometry.setAttribute('depth', new THREE.BufferAttribute(depths, 1));\n    geometry.attributes.position.needsUpdate = true;\n    return geometry;\n  };\n\n  useEffect(() => {\n    if (planeMeshRef.current) {\n      sceneRef.current.remove(planeMeshRef.current);\n      planeMeshRef.current.geometry.dispose();\n      planeMeshRef.current = null;\n    }\n\n    if (materialRef.current && depthMapImage && sceneRef.current) {\n      const img = new Image();\n      img.src = depthMapImage;\n      img.onload = () => {\n        const canvas = document.createElement('canvas');\n        canvas.width = img.width;\n        canvas.height = img.height;\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(img, 0, 0);\n        const depthData = ctx.getImageData(0, 0, img.width, img.height);\n\n        const geometry = createGeometryFromDepthMap(depthData);\n\n        const mesh = new THREE.Mesh(geometry, materialRef.current);\n        planeMeshRef.current = mesh;\n\n        const fov = cameraRef.current.fov;\n        const cameraZ = cameraRef.current.position.z;\n        const containerAspect = canvasRef.current.clientWidth / canvasRef.current.clientHeight;\n        const imageAspect = img.width / img.height;\n        const visibleHeight = 2 * Math.tan(THREE.MathUtils.degToRad(fov / 2)) * cameraZ;\n        const visibleWidth = visibleHeight * containerAspect;\n\n        let scale;\n        if (containerAspect > imageAspect) {\n            scale = visibleHeight / 1; // Geometry height is 1\n        } else {\n            scale = visibleWidth / imageAspect; // Geometry width is imageAspect\n        }\n        mesh.scale.set(scale, scale, 1);\n\n        sceneRef.current.add(mesh);\n      };\n    }\n  }, [depthMapImage]);\n\n  useEffect(() => {\n    if (materialRef.current) {\n      let targetX = 0, targetY = 0;\n      if (viewMode === 'mouse' && mousePosition) {\n        targetX = (mousePosition.x * 2 - 1);\n        targetY = (mousePosition.y * 2 - 1);\n      } else if (viewMode === 'gyro' && orientation) {\n        targetX = (orientation.gamma / -30);\n        targetY = (orientation.beta / -60);\n      } else if (viewMode === 'gyroInverse' && orientation) {\n        targetX = (orientation.gamma / 30);\n        targetY = (orientation.beta / 60);\n      }\n      const easing = 0.05;\n      const currentDelta = materialRef.current.uniforms.mouseDelta.value;\n      currentDelta.x += (targetX - currentDelta.x) * easing;\n      currentDelta.y += (targetY - currentDelta.y) * easing;\n    }\n  }, [mousePosition, orientation, viewMode]);\n\n  useEffect(() => {\n    if (materialRef.current) {\n      materialRef.current.uniforms.focus.value = focus;\n    }\n  }, [focus]);\n\n  useEffect(() => {\n    if (materialRef.current) {\n      materialRef.current.uniforms.sensitivity.value = parallaxStrength * 10; // Map strength to sensitivity\n    }\n  }, [parallaxStrength]);\n\n  useEffect(() => {\n    if (cameraRef.current) {\n      cameraRef.current.position.z = 2 / zoom; // Adjust camera Z based on zoom\n      cameraRef.current.updateProjectionMatrix();\n    }\n  }, [zoom]);\n\n  return <canvas ref={canvasRef} className=\"main-view-canvas\"></canvas>;\n};\n\nfunction App() {\n  const inferenceWorkerRef = useRef(null); // Use useRef to hold the worker instance\n  const [inputSource, setInputSource] = useState(\"demo.png\");\n  const [depthMapSource, setDepthMapSource] = useState(null);\n  const [isDepthMapReady, setIsDepthMapReady] = useState(false);\n  const inputRef = useRef(null);\n  const outputRef = useRef(null);\n  const [processing, setProcessing] = useState(false);\n  const isMobileDevice = () => {\n    return /Mobi|Android/i.test(navigator.userAgent);\n  };\n\n  const [viewMode, setViewMode] = useState(isMobileDevice() ? 'gyro' : 'mouse');\n  const [mousePositionForShader, setMousePositionForShader] = useState({ x: 0.5, y: 0.5 });\n  const [orientationForShader, setOrientationForShader] = useState(null);\n  const webGLContainerRef = useRef(null);\n  const [isGyroAvailable, setIsGyroAvailable] = useState(false);\n  const [parallaxStrength, setParallaxStrength] = useState(0.02);\n  const [focus, setFocus] = useState(0.75);\n  const [isDrawerOpen, setIsDrawerOpen] = useState(false);\n  const [zoom, setZoom] = useState(0.9); // New zoom state\n  const [startX, setStartX] = useState(0); // For swipe to close drawer\n\n  useEffect(() => {\n    inferenceWorkerRef.current = new InferenceWorker(); // Initialize worker in useEffect\n    // Optional: Add cleanup for the worker if workerize-loader provides a terminate method\n    // return () => { if (inferenceWorkerRef.current?.terminate) inferenceWorkerRef.current.terminate(); };\n  }, []); // Empty dependency array ensures this runs only once on mount\n\n  useEffect(() => {\n    if (window.DeviceOrientationEvent) {\n      setIsGyroAvailable(true);\n      const handleDeviceOrientation = (event) => {\n        if (viewMode === 'gyro' || viewMode === 'gyroInverse') {\n          setOrientationForShader({\n            alpha: event.alpha, // Z axis rotation\n            beta: event.beta,   // X axis rotation (front to back tilt)\n            gamma: event.gamma, // Y axis rotation (side to side tilt)\n          });\n        }\n      };\n      window.addEventListener('deviceorientation', handleDeviceOrientation);\n      return () => {\n        window.removeEventListener('deviceorientation', handleDeviceOrientation);\n      };\n    } else {\n      setIsGyroAvailable(false);\n    }\n  }, [viewMode]); // Rerun if viewMode changes to attach/detach listener\n\n  const inferCallback = useCallback(async () => { // Made the callback async directly\n    if (!inferenceWorkerRef.current) {\n      console.error(\"Inference worker is not initialized yet.\");\n      alert(\"Worker not ready, please try again shortly.\");\n      return;\n    }\n    // Ensure inputRef.current is available and has a valid src before processing\n    if (processing || !inputRef.current || !inputRef.current.src || inputRef.current.src === \"\") {\n      return;\n    }\n    setProcessing(true);\n    // Clear previous depth map on canvas before new inference\n    if (outputRef.current) {\n        const ctx = outputRef.current.getContext('2d');\n        ctx.clearRect(0, 0, outputRef.current.width, outputRef.current.height);\n    }\n    setDepthMapSource(null); // Explicitly clear depth map source for WebGLViewer\n    setIsDepthMapReady(false); // Set depth map not ready\n\n    try {\n      let input = tf.browser.fromPixels(inputRef.current);\n      const originalSize = [input.shape[0], input.shape[1]];\n      const modelName = document.getElementById('modelSelect').value;\n      const inputSize = modelName === 'midas' ? [256, 256] : [518, 518];\n      // Ensure input has 3 channels for resizeBilinear\n      if (input.shape[2] === 4) {\n        input = input.slice([0, 0, 0], [input.shape[0], input.shape[1], 3]);\n      }\n      input = tf.image.resizeBilinear(input, inputSize);\n      console.log(input);\n      \n      const inputSerialized = serializeTensor(input);\n      input.dispose(); \n\n      let outputTensor = deserializeTensor(\n        await inferenceWorkerRef.current.infer(inputSerialized) // Use worker from ref\n      );\n      outputTensor = tf.image.resizeBilinear(outputTensor, originalSize);\n      \n      // Draw to outputRef (2D canvas preview)\n      if (outputRef.current) {\n        outputRef.current.width = originalSize[1];\n        outputRef.current.height = originalSize[0];\n        await tf.browser.toPixels(outputTensor, outputRef.current);\n      }\n      \n      // Create data URL for WebGLViewer\n      const tempCanvas = document.createElement('canvas');\n      tempCanvas.width = originalSize[1];\n      tempCanvas.height = originalSize[0];\n      await tf.browser.toPixels(outputTensor.clone(), tempCanvas); // Clone tensor before using for toDataURL if needed elsewhere\n      setDepthMapSource(tempCanvas.toDataURL());\n      setIsDepthMapReady(true);\n      \n      outputTensor.dispose();\n\n    } catch (err) {\n      console.error(\"Inference error:\", err);\n      alert(\"An unknown error occurred during inference.\");\n    } finally {\n      setProcessing(false); \n    }\n  }, [processing, inputRef, outputRef, setDepthMapSource, setProcessing]); // Removed inferenceWorkerRef from deps as it's stable via useRef\n\n  const onDrop = useCallback(\n    (acceptedFiles) => {\n      if (processing) {\n        return;\n      }\n      const fr = new FileReader();\n      fr.onload = () => {\n        setInputSource(fr.result); // This will trigger img.onLoad, which calls inferCallback\n        // Clearing depthMapSource here is good, inferCallback will also clear its canvas part\n        setDepthMapSource(null);\n        setIsDepthMapReady(false);\n        if (outputRef.current) { // Clear the 2D preview canvas as well\n            const ctx = outputRef.current.getContext('2d');\n            if (outputRef.current.width > 0 && outputRef.current.height > 0) {\n                 ctx.clearRect(0, 0, outputRef.current.width, outputRef.current.height);\n            }\n        }\n      };\n      fr.readAsDataURL(acceptedFiles[0]);\n    },\n    [setInputSource, setDepthMapSource, processing, outputRef] // Added outputRef\n  );\n  const { getRootProps, getInputProps, isDragActive } = useDropzone({\n    onDrop,\n    accept: \"image/*\",\n  });\n\n  const handleMouseMoveInViewer = (event) => {\n    if (viewMode === 'mouse' && webGLContainerRef.current) {\n      const rect = webGLContainerRef.current.getBoundingClientRect();\n      const clientX = event.touches ? event.touches[0].clientX : event.clientX;\n      const clientY = event.touches ? event.touches[0].clientY : event.clientY;\n      const x = (clientX - rect.left) / rect.width;\n      const y = (clientY - rect.top) / rect.height;\n      setMousePositionForShader({ x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, 1.0 - y)) });\n    }\n  };\n\n  const toggleDrawer = () => {\n    setIsDrawerOpen(!isDrawerOpen);\n  };\n\n  const handleTouchStart = (e) => {\n    setStartX(e.touches[0].clientX);\n  };\n\n  const handleTouchMove = (e) => {\n    if (isDrawerOpen) {\n      const currentX = e.touches[0].clientX;\n      const diffX = currentX - startX;\n      // If swiping left significantly, close the drawer\n      if (diffX < -50) { // Threshold of 50 pixels\n        setIsDrawerOpen(false);\n      }\n    }\n  };\n\n  return (\n    <div className=\"app-container\">\n      <button className=\"hamburger-menu\" onClick={toggleDrawer}>\n        <span></span>\n        <span></span>\n        <span></span>\n      </button>\n      {isDrawerOpen && <div className=\"overlay\" onClick={toggleDrawer}></div>}\n      <aside\n        className={`sidebar ${isDrawerOpen ? 'sidebar--open' : ''}`}\n        onTouchStart={handleTouchStart}\n        onTouchMove={handleTouchMove}\n      >\n        <h2>控制台</h2>\n        <div className=\"control-group\">\n          <label htmlFor=\"modelSelect\">选择模型</label>\n          <select id=\"modelSelect\" onChange={(e) => inferenceWorkerRef.current.switchModel(e.target.value)}>\n            <option value=\"midas\">Midas</option>\n            <option value=\"depthAnything\">DepthAnything</option>\n          </select>\n\n          <label htmlFor=\"viewModeSelect\">控制模式</label>\n          <select id=\"viewModeSelect\" value={viewMode} onChange={(e) => setViewMode(e.target.value)}>\n            <option value=\"mouse\">鼠标</option>\n            {isGyroAvailable && <option value=\"gyro\">陀螺仪</option>}\n            {isGyroAvailable && <option value=\"gyroInverse\">陀螺仪(反向)</option>}\n          </select>\n          {!isGyroAvailable && (viewMode === 'gyro' || viewMode === 'gyroInverse') && <p style={{color: 'orange'}}>陀螺仪不可用或不支持。</p>}\n        </div>\n        \n        <div className=\"control-group\">\n          <label htmlFor=\"parallaxStrengthRange\">位移强度: {parallaxStrength.toFixed(3)}</label>\n          <input \n              type=\"range\" \n              id=\"parallaxStrengthRange\" \n              min=\"0.001\" \n              max=\"0.1\" \n              step=\"0.001\" \n              value={parallaxStrength} \n              onChange={(e) => setParallaxStrength(parseFloat(e.target.value))} \n              onTouchMove={(e) => e.stopPropagation()} // Prevent sidebar from closing when sliding\n            />\n        </div>\n\n        <div className=\"control-group\">\n          <label htmlFor=\"focusRange\">焦点: {focus.toFixed(2)}</label>\n          <input \n              type=\"range\" \n              id=\"focusRange\" \n              min=\"0.0\" \n              max=\"1.0\" \n              step=\"0.01\" \n              value={focus} \n              onChange={(e) => setFocus(parseFloat(e.target.value))} \n              onTouchMove={(e) => e.stopPropagation()} // Prevent sidebar from closing when sliding\n            />\n        </div>\n\n        <div className=\"image-preview-area\">\n            <h3>原始图像</h3>\n            <div \n              className={[\n                \"image-dropzone\",\n                isDragActive\n                  ? \"image-dropzone--highlight\"\n                  : \"image-dropzone--default\",\n              ].join(\" \")}\n              {...getRootProps()}\n            >\n              <input {...getInputProps()} />\n              {inputSource ? (\n                <img ref={inputRef} alt=\"Input\" src={inputSource} className=\"preview-image\" onLoad={inferCallback} />\n              ) : (\n                <p>Drop an image here, or click to select</p>\n              )}\n            </div>\n        </div>\n\n        <div className=\"image-preview-area\">\n            <h3>深度图</h3>\n            <canvas ref={outputRef} className=\"preview-image\"></canvas>\n        </div>\n        \n        <button onClick={inferCallback} disabled={processing || !inputSource}>\n          {processing ? \"生成中...\" : \"生成深度图\"}\n        </button>\n        <div className=\"made-by-text\">\n          Made by J\n        </div>\n      </aside>\n      <main\n        className=\"main-content\"\n        onMouseMove={handleMouseMoveInViewer}\n        onTouchMove={handleMouseMoveInViewer}\n        ref={webGLContainerRef}\n      >\n        <h1 className=\"main-title\">单目深度图估算</h1>\n        <div className=\"webgl-viewer-container\">\n          {processing && !isDepthMapReady && (\n            <div className=\"loading-overlay\">\n              <p>生成中...</p>\n            </div>\n          )}\n          <WebGLViewer \n            inputImage={inputSource} \n            depthMapImage={isDepthMapReady ? depthMapSource : null} \n            viewMode={viewMode} \n            mousePosition={mousePositionForShader}\n            orientation={orientationForShader}\n            parallaxStrength={parallaxStrength}\n            focus={focus}\n            zoom={zoom} />\n          <div className=\"viewer-controls\">\n            <button onClick={() => {\n              setZoom(0.9)\n              setMousePositionForShader({ x: 0.5, y: 0.5 });\n            }}>重置</button>\n            <label htmlFor=\"zoomRange\">{zoom.toFixed(2)}x</label>\n            <input \n              type=\"range\" \n              id=\"zoomRange\" \n              min=\"0.1\" \n              max=\"1.5\" \n              step=\"0.1\" \n              value={zoom} \n              onChange={(e) => setZoom(parseFloat(e.target.value))} \n            />\n          </div>\n        </div>\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}