{"version":3,"sources":["inference.worker.js","utils.js","App.js","index.js"],"names":["addMethods","methods","module","exports","w","Worker","name","deserializeTensor","data","shape","tf","WebGLViewer","inputImage","depthMapImage","viewMode","mousePosition","orientation","parallaxStrength","focus","zoom","canvasRef","useRef","rendererRef","sceneRef","cameraRef","materialRef","imageTextureRef","depthTextureRef","planeMeshRef","handleResize","useCallback","current","parentElement","newWidth","clientWidth","newHeight","clientHeight","setSize","aspect","updateProjectionMatrix","scale","imageAspect","image","width","height","fov","cameraZ","position","z","containerAspect","visibleHeight","Math","tan","THREE","degToRad","set","useEffect","canvas","renderer","antialias","setPixelRatio","window","devicePixelRatio","scene","camera","material","vertexShader","fragmentShader","uniforms","u_image","value","mouseDelta","meshDepth","sensitivity","animate","requestAnimationFrame","render","addEventListener","removeEventListener","dispose","load","texture","remove","geometry","img","Image","src","onload","document","createElement","ctx","getContext","drawImage","depthData","vertices","attributes","array","depths","Float32Array","length","i","vertexIndex","u","uv","v","x","floor","pixelIndex","depthValue","setAttribute","needsUpdate","createGeometryFromDepthMap","getImageData","mesh","add","targetX","targetY","y","gamma","beta","currentDelta","ref","className","App","inferenceWorkerRef","useState","inputSource","setInputSource","depthMapSource","setDepthMapSource","isDepthMapReady","setIsDepthMapReady","inputRef","outputRef","processing","setProcessing","test","navigator","userAgent","setViewMode","mousePositionForShader","setMousePositionForShader","orientationForShader","setOrientationForShader","webGLContainerRef","isGyroAvailable","setIsGyroAvailable","setParallaxStrength","setFocus","isDrawerOpen","setIsDrawerOpen","setZoom","currentModel","setCurrentModel","startX","setStartX","InferenceWorker","switchModel","inferCallback","DeviceOrientationEvent","handleDeviceOrientation","event","alpha","a","console","error","alert","naturalWidth","naturalHeight","clearRect","input","fromPixels","originalSize","slice","inputSerialized","tensor","dataSync","infer","outputTensor","resizeBilinear","toPixels","tempCanvas","clone","toDataURL","onDrop","acceptedFiles","fr","FileReader","result","readAsDataURL","useDropzone","accept","getRootProps","getInputProps","isDragActive","handleMouseMoveInViewer","rect","getBoundingClientRect","clientX","touches","clientY","left","top","max","min","toggleDrawer","onClick","onTouchStart","e","onTouchMove","htmlFor","id","onChange","target","style","color","toFixed","type","step","parseFloat","stopPropagation","join","alt","onLoad","disabled","onMouseMove","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.406d112b.chunk.js","sourcesContent":["\n\t\t\t\tvar addMethods = require(\"../node_modules/workerize-loader/dist/rpc-wrapper.js\")\n\t\t\t\tvar methods = [\"switchModel\",\"infer\"]\n\t\t\t\tmodule.exports = function() {\n\t\t\t\t\tvar w = new Worker(__webpack_public_path__ + \"0026fcd57af6c381ff6f.worker.js\", { name: \"[hash].worker.js\" })\n\t\t\t\t\taddMethods(w, methods)\n\t\t\t\t\t\n\t\t\t\t\treturn w\n\t\t\t\t}\n\t\t\t","import * as tf from \"@tensorflow/tfjs\";\n\nexport const serializeTensor = (tensor) => ({\n  data: tensor.dataSync(),\n  shape: tensor.shape,\n});\nexport const deserializeTensor = ({ data, shape }) => tf.tensor(data, shape);\n","/* eslint import/no-webpack-loader-syntax: off */\r\nimport \"./App.css\";\r\nimport { useCallback, useRef, useState, useEffect } from \"react\"; // useMemo removed as it's replaced by useEffect/useRef pattern\r\nimport { useDropzone } from \"react-dropzone\";\r\nimport * as tf from \"@tensorflow/tfjs\";\r\nimport InferenceWorker from \"workerize-loader!./inference.worker\";\r\nimport { serializeTensor, deserializeTensor } from \"./utils\";\r\n\r\nimport * as THREE from 'three'; // Assuming THREE is installed or will be\r\n\r\n// Basic Shader code (simplified, to be adapted from tiefling/shader.js)\r\nconst vertexShader = `\r\n  attribute float depth;\r\n  varying vec2 vUv;\r\n  uniform vec2 mouseDelta;\r\n  uniform float focus;\r\n  uniform float meshDepth;\r\n  uniform float sensitivity;\r\n\r\n  void main() {\r\n    vUv = uv;\r\n    vec3 pos = position;\r\n\r\n    float actualDepth = depth * meshDepth;\r\n    float focusDepth = focus * meshDepth;\r\n\r\n    // Rotational displacement (relative to focus depth)\r\n    vec2 rotate = mouseDelta * sensitivity * \r\n        (1.0 - focus) * \r\n        (actualDepth - focusDepth) * \r\n        vec2(-1.0, 1.0);\r\n\r\n    // Calculate edge proximity factor (0 at edges, 1 in center)\r\n    float edgeWidth = 0.01; // controls edge stiffness\r\n    vec2 edgeFactorVec = smoothstep(0.0, edgeWidth, vUv) * \r\n                        smoothstep(1.0, 1.0 - edgeWidth, vUv);\r\n    float edgeFactor = edgeFactorVec.x * edgeFactorVec.y;\r\n\r\n    // Apply displacement with edge preservation\r\n    pos.xy += rotate * edgeFactor;\r\n\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n  }\r\n`;\r\n\r\nconst fragmentShader = `\r\n  uniform sampler2D u_image;\r\n  varying vec2 vUv;\r\n\r\n  void main() {\r\n    gl_FragColor = texture2D(u_image, vUv);\r\n  }\r\n`;\r\n\r\nconst WebGLViewer = ({ inputImage, depthMapImage, viewMode, mousePosition, orientation, parallaxStrength, focus, zoom }) => {\r\n  const canvasRef = useRef(null);\r\n  const rendererRef = useRef(null);\r\n  const sceneRef = useRef(null);\r\n  const cameraRef = useRef(null);\r\n  const materialRef = useRef(null);\r\n  const imageTextureRef = useRef(null);\r\n  const depthTextureRef = useRef(null);\r\n  const planeMeshRef = useRef(null);\r\n\r\n  const handleResize = useCallback(() => {\r\n    if (canvasRef.current && rendererRef.current && cameraRef.current && canvasRef.current.parentElement) {\r\n        const parentElement = canvasRef.current.parentElement;\r\n        const newWidth = parentElement.clientWidth;\r\n        const newHeight = parentElement.clientHeight;\r\n        rendererRef.current.setSize(newWidth, newHeight);\r\n        cameraRef.current.aspect = newWidth / newHeight;\r\n        cameraRef.current.updateProjectionMatrix();\r\n\r\n        // Recalculate mesh scale if planeMeshRef.current exists\r\n        if (planeMeshRef.current && imageTextureRef.current) {\r\n            const imageAspect = imageTextureRef.current.image.width / imageTextureRef.current.image.height;\r\n            const fov = cameraRef.current.fov;\r\n            const cameraZ = cameraRef.current.position.z;\r\n            const containerAspect = newWidth / newHeight;\r\n            const visibleHeight = 2 * Math.tan(THREE.MathUtils.degToRad(fov / 2)) * cameraZ;\r\n            const visibleWidth = visibleHeight * containerAspect;\r\n\r\n            let scale;\r\n            if (containerAspect > imageAspect) {\r\n                scale = visibleHeight / 1; // Geometry height is 1\r\n            } else {\r\n                scale = visibleWidth / imageAspect; // Geometry width is imageAspect\r\n            }\r\n            planeMeshRef.current.scale.set(scale, scale, 1);\r\n        }\r\n    }\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    // Initialize THREE.js scene\r\n    const canvas = canvasRef.current;\r\n    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });\r\n    renderer.setSize(canvas.clientWidth, canvas.clientHeight);\r\n    renderer.setPixelRatio(window.devicePixelRatio);\r\n    rendererRef.current = renderer;\r\n\r\n    const scene = new THREE.Scene();\r\n    sceneRef.current = scene;\r\n\r\n    const fov = 45;\r\n    const camera = new THREE.PerspectiveCamera(fov, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);\r\n    camera.position.z = 2;\r\n    cameraRef.current = camera;\r\n\r\n    const geometry = new THREE.PlaneGeometry(1, 1);\r\n    const material = new THREE.ShaderMaterial({\r\n      vertexShader,\r\n      fragmentShader,\r\n      uniforms: {\r\n        u_image: { value: null },\r\n        mouseDelta: { value: new THREE.Vector2(0, 0) },\r\n        focus: { value: focus },\r\n        meshDepth: { value: 1.0 },\r\n        sensitivity: { value: 0.5 }\r\n      },\r\n    });\r\n    materialRef.current = material;\r\n\r\n    // Plane will be created and added when depth map is ready\r\n    // const plane = new THREE.Mesh(geometry, material);\r\n    // scene.add(plane);\r\n\r\n    const animate = () => {\r\n      requestAnimationFrame(animate);\r\n      renderer.render(scene, camera);\r\n    };\r\n    animate();\r\n\r\n    window.addEventListener('resize', handleResize);\r\n    handleResize();\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', handleResize);\r\n      if (rendererRef.current) rendererRef.current.dispose();\r\n      if(imageTextureRef.current) imageTextureRef.current.dispose(); // Dispose textures on unmount\r\n      if(depthTextureRef.current) depthTextureRef.current.dispose(); // Dispose textures on unmount\r\n      // geometry.dispose(); material.dispose(); // If created here\r\n    };\r\n  }, [handleResize]);\r\n\r\n  useEffect(() => {\r\n    if (materialRef.current && inputImage) {\r\n      if (imageTextureRef.current) imageTextureRef.current.dispose();\r\n      const loader = new THREE.TextureLoader();\r\n      loader.load(inputImage, (texture) => {\r\n        imageTextureRef.current = texture;\r\n        materialRef.current.uniforms.u_image.value = texture;\r\n        // Resize logic will be handled when the mesh is created/updated\r\n      });\r\n    }\r\n  }, [inputImage]);\r\n\r\n  const createGeometryFromDepthMap = (depthData) => {\r\n    const width = depthData.width;\r\n    const height = depthData.height;\r\n    const imageAspect = width / height;\r\n    const geometry = new THREE.PlaneGeometry(imageAspect, 1, width - 1, height - 1);\r\n    const vertices = geometry.attributes.position.array;\r\n    const depths = new Float32Array(vertices.length / 3);\r\n\r\n    for (let i = 0; i < vertices.length; i += 3) {\r\n        const vertexIndex = i / 3;\r\n        const u = geometry.attributes.uv.array[vertexIndex * 2];\r\n        const v = 1.0 - geometry.attributes.uv.array[vertexIndex * 2 + 1];\r\n        const x = Math.floor(u * (width - 1));\r\n        const y = Math.floor(v * (height - 1));\r\n        const pixelIndex = (y * width + x) * 4;\r\n        const depthValue = depthData.data[pixelIndex] / 255.0;\r\n\r\n        vertices[i + 2] = depthValue; // Set z based on depth\r\n        depths[vertexIndex] = depthValue;\r\n    }\r\n\r\n    geometry.setAttribute('depth', new THREE.BufferAttribute(depths, 1));\r\n    geometry.attributes.position.needsUpdate = true;\r\n    return geometry;\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (planeMeshRef.current) {\r\n      sceneRef.current.remove(planeMeshRef.current);\r\n      planeMeshRef.current.geometry.dispose();\r\n      planeMeshRef.current = null;\r\n    }\r\n\r\n    if (materialRef.current && depthMapImage && sceneRef.current) {\r\n      const img = new Image();\r\n      img.src = depthMapImage;\r\n      img.onload = () => {\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = img.width;\r\n        canvas.height = img.height;\r\n        const ctx = canvas.getContext('2d');\r\n        ctx.drawImage(img, 0, 0);\r\n        const depthData = ctx.getImageData(0, 0, img.width, img.height);\r\n\r\n        const geometry = createGeometryFromDepthMap(depthData);\r\n\r\n        const mesh = new THREE.Mesh(geometry, materialRef.current);\r\n        planeMeshRef.current = mesh;\r\n\r\n        const fov = cameraRef.current.fov;\r\n        const cameraZ = cameraRef.current.position.z;\r\n        const containerAspect = canvasRef.current.clientWidth / canvasRef.current.clientHeight;\r\n        const imageAspect = img.width / img.height;\r\n        const visibleHeight = 2 * Math.tan(THREE.MathUtils.degToRad(fov / 2)) * cameraZ;\r\n        const visibleWidth = visibleHeight * containerAspect;\r\n\r\n        let scale;\r\n        if (containerAspect > imageAspect) {\r\n            scale = visibleHeight / 1; // Geometry height is 1\r\n        } else {\r\n            scale = visibleWidth / imageAspect; // Geometry width is imageAspect\r\n        }\r\n        mesh.scale.set(scale, scale, 1);\r\n\r\n        sceneRef.current.add(mesh);\r\n      };\r\n    }\r\n  }, [depthMapImage]);\r\n\r\n  useEffect(() => {\r\n    if (materialRef.current) {\r\n      let targetX = 0, targetY = 0;\r\n      if (viewMode === 'mouse' && mousePosition) {\r\n        targetX = (mousePosition.x * 2 - 1);\r\n        targetY = (mousePosition.y * 2 - 1);\r\n      } else if (viewMode === 'gyro' && orientation) {\r\n        targetX = (orientation.gamma / -30);\r\n        targetY = (orientation.beta / -60);\r\n      } else if (viewMode === 'gyroInverse' && orientation) {\r\n        targetX = (orientation.gamma / 30);\r\n        targetY = (orientation.beta / 60);\r\n      }\r\n      const easing = 0.05;\r\n      const currentDelta = materialRef.current.uniforms.mouseDelta.value;\r\n      currentDelta.x += (targetX - currentDelta.x) * easing;\r\n      currentDelta.y += (targetY - currentDelta.y) * easing;\r\n    }\r\n  }, [mousePosition, orientation, viewMode]);\r\n\r\n  useEffect(() => {\r\n    if (materialRef.current) {\r\n      materialRef.current.uniforms.focus.value = focus;\r\n    }\r\n  }, [focus]);\r\n\r\n  useEffect(() => {\r\n    if (materialRef.current) {\r\n      materialRef.current.uniforms.sensitivity.value = parallaxStrength * 10; // Map strength to sensitivity\r\n    }\r\n  }, [parallaxStrength]);\r\n\r\n  useEffect(() => {\r\n    if (cameraRef.current) {\r\n      cameraRef.current.position.z = 2 / zoom; // Adjust camera Z based on zoom\r\n      cameraRef.current.updateProjectionMatrix();\r\n    }\r\n  }, [zoom]);\r\n\r\n  return <canvas ref={canvasRef} className=\"main-view-canvas\"></canvas>;\r\n};\r\n\r\nfunction App() {\r\n  const inferenceWorkerRef = useRef(null); // Use useRef to hold the worker instance\r\n  const [inputSource, setInputSource] = useState(\"\");\r\n  const [depthMapSource, setDepthMapSource] = useState(null);\r\n  const [isDepthMapReady, setIsDepthMapReady] = useState(false);\r\n  const inputRef = useRef(null);\r\n  const outputRef = useRef(null);\r\n  const [processing, setProcessing] = useState(false);\r\n  const isMobileDevice = () => {\r\n    return /Mobi|Android/i.test(navigator.userAgent);\r\n  };\r\n\r\n  const [viewMode, setViewMode] = useState(isMobileDevice() ? 'gyro' : 'mouse');\r\n  const [mousePositionForShader, setMousePositionForShader] = useState({ x: 0.5, y: 0.5 });\r\n  const [orientationForShader, setOrientationForShader] = useState(null);\r\n  const webGLContainerRef = useRef(null);\r\n  const [isGyroAvailable, setIsGyroAvailable] = useState(false);\r\n  const [parallaxStrength, setParallaxStrength] = useState(0.025);\r\n  const [focus, setFocus] = useState(0.75);\r\n  const [isDrawerOpen, setIsDrawerOpen] = useState(false);\r\n  const [zoom, setZoom] = useState(0.9); // New zoom state\r\n  const [currentModel, setCurrentModel] = useState('depthAnything'); // Add currentModel state\r\n  const [startX, setStartX] = useState(0); // For swipe to close drawer\r\n\r\n  useEffect(() => {\r\n    inferenceWorkerRef.current = new InferenceWorker(); // Initialize worker in useEffect\r\n    // Optional: Add cleanup for the worker if workerize-loader provides a terminate method\r\n    // return () => { if (inferenceWorkerRef.current?.terminate) inferenceWorkerRef.current.terminate(); };\r\n  }, []); // Empty dependency array ensures this runs only once on mount\r\n\r\n  useEffect(() => {\r\n    if (inferenceWorkerRef.current) {\r\n      inferenceWorkerRef.current.switchModel(currentModel);\r\n      // Re-run inference if input source exists and not currently processing\r\n      if (inputSource && !processing) {\r\n        inferCallback();\r\n      }\r\n    }\r\n  }, [currentModel]); // Switch model in worker when currentModel changes\r\n\r\n  useEffect(() => {\r\n    if (window.DeviceOrientationEvent) {\r\n      setIsGyroAvailable(true);\r\n      const handleDeviceOrientation = (event) => {\r\n        if (viewMode === 'gyro' || viewMode === 'gyroInverse') {\r\n          setOrientationForShader({\r\n            alpha: event.alpha, // Z axis rotation\r\n            beta: event.beta,   // X axis rotation (front to back tilt)\r\n            gamma: event.gamma, // Y axis rotation (side to side tilt)\r\n          });\r\n        }\r\n      };\r\n      window.addEventListener('deviceorientation', handleDeviceOrientation);\r\n      return () => {\r\n        window.removeEventListener('deviceorientation', handleDeviceOrientation);\r\n      };\r\n    } else {\r\n      setIsGyroAvailable(false);\r\n    }\r\n  }, [viewMode]); // Rerun if viewMode changes to attach/detach listener\r\n\r\n  const inferCallback = useCallback(async () => { // Made the callback async directly\r\n    if (!inferenceWorkerRef.current) {\r\n      console.error(\"Inference worker is not initialized yet.\");\r\n      alert(\"Worker not ready, please try again shortly.\");\r\n      return;\r\n    }\r\n    // Ensure inputRef.current is available and has a valid src and dimensions before processing\r\n    if (processing || !inputRef.current || !inputRef.current.src || inputRef.current.src === \"\" || inputRef.current.naturalWidth === 0 || inputRef.current.naturalHeight === 0) {\r\n      return;\r\n    }\r\n    setProcessing(true);\r\n    // Clear previous depth map on canvas before new inference\r\n    if (outputRef.current) {\r\n        const ctx = outputRef.current.getContext('2d');\r\n        ctx.clearRect(0, 0, outputRef.current.width, outputRef.current.height);\r\n    }\r\n    setDepthMapSource(null); // Explicitly clear depth map source for WebGLViewer\r\n    setIsDepthMapReady(false); // Set depth map not ready\r\n\r\n    try {\r\n      let input = tf.browser.fromPixels(inputRef.current);\r\n      const originalSize = [input.shape[0], input.shape[1]];\r\n      // Ensure input has 3 channels for resizeBilinear\r\n      if (input.shape[2] === 4) {\r\n        input = input.slice([0, 0, 0], [input.shape[0], input.shape[1], 3]);\r\n      }\r\n      \r\n      const inputSerialized = serializeTensor(input);\r\n      input.dispose(); \r\n\r\n      let outputTensor = deserializeTensor(\r\n        await inferenceWorkerRef.current.infer(inputSerialized) // Use worker from ref\r\n      );\r\n      outputTensor = tf.image.resizeBilinear(outputTensor, originalSize);\r\n      \r\n      // Draw to outputRef (2D canvas preview)\r\n      if (outputRef.current) {\r\n        outputRef.current.width = originalSize[1];\r\n        outputRef.current.height = originalSize[0];\r\n        await tf.browser.toPixels(outputTensor, outputRef.current);\r\n      }\r\n      \r\n      // Create data URL for WebGLViewer\r\n      const tempCanvas = document.createElement('canvas');\r\n      tempCanvas.width = originalSize[1];\r\n      tempCanvas.height = originalSize[0];\r\n      await tf.browser.toPixels(outputTensor.clone(), tempCanvas); // Clone tensor before using for toDataURL if needed elsewhere\r\n      setDepthMapSource(tempCanvas.toDataURL());\r\n      setIsDepthMapReady(true);\r\n      \r\n      outputTensor.dispose();\r\n\r\n    } catch (err) {\r\n      console.error(\"Inference error:\", err);\r\n      alert(\"An unknown error occurred during inference.\");\r\n    } finally {\r\n      setProcessing(false); \r\n    }\r\n  }, [processing, inputRef, outputRef, setDepthMapSource, setProcessing, currentModel]); // Added currentModel to deps\r\n\r\n  const onDrop = useCallback(\r\n    (acceptedFiles) => {\r\n      if (processing) {\r\n        return;\r\n      }\r\n      const fr = new FileReader();\r\n      fr.onload = () => {\r\n        setInputSource(fr.result); // This will trigger img.onLoad, which calls inferCallback\r\n        // Clearing depthMapSource here is good, inferCallback will also clear its canvas part\r\n        setDepthMapSource(null);\r\n        setIsDepthMapReady(false);\r\n        if (outputRef.current) { // Clear the 2D preview canvas as well\r\n            const ctx = outputRef.current.getContext('2d');\r\n            if (outputRef.current.width > 0 && outputRef.current.height > 0) {\r\n                 ctx.clearRect(0, 0, outputRef.current.width, outputRef.current.height);\r\n            }\r\n        }\r\n      };\r\n      fr.readAsDataURL(acceptedFiles[0]);\r\n    },\r\n    [setInputSource, setDepthMapSource, processing, outputRef] // Added outputRef\r\n  );\r\n  const { getRootProps, getInputProps, isDragActive } = useDropzone({\r\n    onDrop,\r\n    accept: \"image/*\",\r\n  });\r\n\r\n  const handleMouseMoveInViewer = (event) => {\r\n    if (viewMode === 'mouse' && webGLContainerRef.current) {\r\n      const rect = webGLContainerRef.current.getBoundingClientRect();\r\n      const clientX = event.touches ? event.touches[0].clientX : event.clientX;\r\n      const clientY = event.touches ? event.touches[0].clientY : event.clientY;\r\n      const x = (clientX - rect.left) / rect.width;\r\n      const y = (clientY - rect.top) / rect.height;\r\n      setMousePositionForShader({ x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, 1.0 - y)) });\r\n    }\r\n  };\r\n\r\n  const toggleDrawer = () => {\r\n    setIsDrawerOpen(!isDrawerOpen);\r\n  };\r\n\r\n  const handleTouchStart = (e) => {\r\n    setStartX(e.touches[0].clientX);\r\n  };\r\n\r\n  const handleTouchMove = (e) => {\r\n    if (isDrawerOpen) {\r\n      const currentX = e.touches[0].clientX;\r\n      const diffX = currentX - startX;\r\n      // If swiping left significantly, close the drawer\r\n      if (diffX < -50) { // Threshold of 50 pixels\r\n        setIsDrawerOpen(false);\r\n      }\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"app-container\">\r\n      <button className=\"hamburger-menu\" onClick={toggleDrawer}>\r\n        <span></span>\r\n        <span></span>\r\n        <span></span>\r\n      </button>\r\n      {isDrawerOpen && <div className=\"overlay\" onClick={toggleDrawer}></div>}\r\n      <aside\r\n        className={`sidebar ${isDrawerOpen ? 'sidebar--open' : ''}`}\r\n        onTouchStart={handleTouchStart}\r\n        onTouchMove={handleTouchMove}\r\n      >\r\n        <h2>控制台</h2>\r\n        <div className=\"control-group\">\r\n          <label htmlFor=\"modelSelect\">选择模型</label>\r\n          <select id=\"modelSelect\" value={currentModel} onChange={(e) => setCurrentModel(e.target.value)}>\r\n            <option value=\"depthAnything\">DepthAnything</option>\r\n            <option value=\"midas\">Midas</option>\r\n          </select>\r\n\r\n          <label htmlFor=\"viewModeSelect\">控制模式</label>\r\n          <select id=\"viewModeSelect\" value={viewMode} onChange={(e) => setViewMode(e.target.value)}>\r\n            <option value=\"mouse\">鼠标</option>\r\n            {isGyroAvailable && <option value=\"gyro\">陀螺仪</option>}\r\n            {isGyroAvailable && <option value=\"gyroInverse\">陀螺仪(反向)</option>}\r\n          </select>\r\n          {!isGyroAvailable && (viewMode === 'gyro' || viewMode === 'gyroInverse') && <p style={{color: 'orange'}}>陀螺仪不可用或不支持。</p>}\r\n        </div>\r\n        \r\n        <div className=\"control-group\">\r\n          <label htmlFor=\"parallaxStrengthRange\">位移强度: {parallaxStrength.toFixed(3)}</label>\r\n          <input \r\n              type=\"range\" \r\n              id=\"parallaxStrengthRange\" \r\n              min=\"0.001\" \r\n              max=\"0.1\" \r\n              step=\"0.001\" \r\n              value={parallaxStrength} \r\n              onChange={(e) => setParallaxStrength(parseFloat(e.target.value))} \r\n              onTouchMove={(e) => e.stopPropagation()} // Prevent sidebar from closing when sliding\r\n            />\r\n        </div>\r\n\r\n        <div className=\"control-group\">\r\n          <label htmlFor=\"focusRange\">焦点: {focus.toFixed(2)}</label>\r\n          <input \r\n              type=\"range\" \r\n              id=\"focusRange\" \r\n              min=\"0.0\" \r\n              max=\"1.0\" \r\n              step=\"0.01\" \r\n              value={focus} \r\n              onChange={(e) => setFocus(parseFloat(e.target.value))} \r\n              onTouchMove={(e) => e.stopPropagation()} // Prevent sidebar from closing when sliding\r\n            />\r\n        </div>\r\n\r\n        <div className=\"image-preview-area\">\r\n            <h3>原始图像</h3>\r\n            <div \r\n              className={[\r\n                \"image-dropzone\",\r\n                isDragActive\r\n                  ? \"image-dropzone--highlight\"\r\n                  : \"image-dropzone--default\",\r\n              ].join(\" \")}\r\n              {...getRootProps()}\r\n            >\r\n              <input {...getInputProps()} />\r\n              {inputSource ? (\r\n                <img ref={inputRef} alt=\"Input\" src={inputSource} className=\"preview-image\" onLoad={inferCallback} />\r\n              ) : (\r\n                <p>点击上传，或拖拽图片至此处</p>\r\n              )}\r\n            </div>\r\n        </div>\r\n\r\n        <div className=\"image-preview-area\">\r\n            <h3>深度图</h3>\r\n            <canvas ref={outputRef} className=\"preview-image\"></canvas>\r\n        </div>\r\n        \r\n        <button onClick={inferCallback} disabled={processing || !inputSource}>\r\n          {processing ? \"生成中...\" : \"生成深度图\"}\r\n        </button>\r\n        <div className=\"made-by-text\">\r\n          Made by J\r\n        </div>\r\n      </aside>\r\n      <main\r\n        className=\"main-content\"\r\n        onMouseMove={handleMouseMoveInViewer}\r\n        onTouchMove={handleMouseMoveInViewer}\r\n        ref={webGLContainerRef}\r\n      >\r\n        <h1 className=\"main-title\">单目深度图估算</h1>\r\n        <div className=\"webgl-viewer-container\">\r\n          {processing && !isDepthMapReady && (\r\n            <div className=\"loading-overlay\">\r\n              <p>生成中...</p>\r\n            </div>\r\n          )}\r\n          <WebGLViewer \r\n            inputImage={inputSource} \r\n            depthMapImage={isDepthMapReady ? depthMapSource : null} \r\n            viewMode={viewMode} \r\n            mousePosition={mousePositionForShader}\r\n            orientation={orientationForShader}\r\n            parallaxStrength={parallaxStrength}\r\n            focus={focus}\r\n            zoom={zoom} />\r\n          <div className=\"viewer-controls\">\r\n            <button onClick={() => {\r\n              setZoom(0.9)\r\n              setMousePositionForShader({ x: 0.5, y: 0.5 });\r\n            }}>重置</button>\r\n            <label htmlFor=\"zoomRange\">{zoom.toFixed(2)}x</label>\r\n            <input \r\n              type=\"range\" \r\n              id=\"zoomRange\" \r\n              min=\"0.1\" \r\n              max=\"1.5\" \r\n              step=\"0.1\" \r\n              value={zoom} \r\n              onChange={(e) => setZoom(parseFloat(e.target.value))} \r\n            />\r\n          </div>\r\n        </div>\r\n      </main>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}