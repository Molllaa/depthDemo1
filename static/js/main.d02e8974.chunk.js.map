{"version":3,"sources":["inference.worker.js","utils.js","App.js","index.js"],"names":["addMethods","methods","module","exports","w","Worker","name","deserializeTensor","data","shape","tf","WebGLViewer","inputImage","depthMapImage","viewMode","mousePosition","orientation","parallaxStrength","focus","zoom","canvasRef","useRef","rendererRef","sceneRef","cameraRef","materialRef","imageTextureRef","depthTextureRef","planeMeshRef","handleResize","useCallback","current","parentElement","newWidth","clientWidth","newHeight","clientHeight","setSize","aspect","updateProjectionMatrix","scale","imageAspect","image","width","height","fov","cameraZ","position","z","containerAspect","visibleHeight","Math","tan","THREE","degToRad","set","useEffect","canvas","renderer","antialias","setPixelRatio","window","devicePixelRatio","scene","camera","material","vertexShader","fragmentShader","uniforms","u_image","value","mouseDelta","meshDepth","sensitivity","animate","requestAnimationFrame","render","addEventListener","removeEventListener","dispose","load","texture","remove","geometry","img","Image","src","onload","document","createElement","ctx","getContext","drawImage","depthData","vertices","attributes","array","depths","Float32Array","length","i","vertexIndex","u","uv","v","x","floor","pixelIndex","depthValue","setAttribute","needsUpdate","createGeometryFromDepthMap","getImageData","mesh","add","targetX","targetY","y","gamma","beta","currentDelta","ref","className","App","inferenceWorkerRef","useState","inputSource","setInputSource","depthMapSource","setDepthMapSource","isDepthMapReady","setIsDepthMapReady","inputRef","outputRef","processing","setProcessing","isModelLoaded","setIsModelLoaded","test","navigator","userAgent","setViewMode","mousePositionForShader","setMousePositionForShader","orientationForShader","setOrientationForShader","webGLContainerRef","isGyroAvailable","setIsGyroAvailable","setParallaxStrength","setFocus","isDrawerOpen","setIsDrawerOpen","setZoom","currentModel","setCurrentModel","startX","setStartX","InferenceWorker","checkModelLoaded","a","isLoaded","setTimeout","console","error","switchModel","then","success","inferCallback","DeviceOrientationEvent","handleDeviceOrientation","event","alpha","alert","naturalWidth","naturalHeight","clearRect","originalHeight","originalWidth","scaledHeight","scaledWidth","MAX_TEXTURE_SIZE","aspectRatio","log","tempCanvas","input","fromPixels","originalSize","slice","inputSerialized","tensor","dataSync","infer","outputTensor","resizeBilinear","toPixels","depthMapCanvas","clone","toDataURL","message","includes","onDrop","acceptedFiles","fr","FileReader","result","readAsDataURL","useDropzone","accept","getRootProps","getInputProps","isDragActive","handleMouseMoveInViewer","rect","getBoundingClientRect","clientX","touches","clientY","left","top","max","min","toggleDrawer","onClick","onTouchStart","e","onTouchMove","htmlFor","id","onChange","target","style","color","toFixed","type","step","parseFloat","stopPropagation","join","alt","onLoad","undefined","disabled","onMouseMove","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.d02e8974.chunk.js","sourcesContent":["\n\t\t\t\tvar addMethods = require(\"../node_modules/workerize-loader/dist/rpc-wrapper.js\")\n\t\t\t\tvar methods = [\"isModelLoaded\",\"switchModel\",\"infer\"]\n\t\t\t\tmodule.exports = function() {\n\t\t\t\t\tvar w = new Worker(__webpack_public_path__ + \"5048cbc94aa7c76adbed.worker.js\", { name: \"[hash].worker.js\" })\n\t\t\t\t\taddMethods(w, methods)\n\t\t\t\t\t\n\t\t\t\t\treturn w\n\t\t\t\t}\n\t\t\t","import * as tf from \"@tensorflow/tfjs\";\n\nexport const serializeTensor = (tensor) => ({\n  data: tensor.dataSync(),\n  shape: tensor.shape,\n});\nexport const deserializeTensor = ({ data, shape }) => tf.tensor(data, shape);\n","/* eslint import/no-webpack-loader-syntax: off */\r\nimport \"./App.css\";\r\nimport { useCallback, useRef, useState, useEffect } from \"react\"; // useMemo removed as it's replaced by useEffect/useRef pattern\r\nimport { useDropzone } from \"react-dropzone\";\r\nimport * as tf from \"@tensorflow/tfjs\";\r\nimport InferenceWorker from \"workerize-loader!./inference.worker\";\r\nimport { serializeTensor, deserializeTensor } from \"./utils\";\r\n\r\nimport * as THREE from 'three'; // Assuming THREE is installed or will be\r\n\r\n// Basic Shader code (simplified, to be adapted from tiefling/shader.js)\r\nconst vertexShader = `\r\n  attribute float depth;\r\n  varying vec2 vUv;\r\n  uniform vec2 mouseDelta;\r\n  uniform float focus;\r\n  uniform float meshDepth;\r\n  uniform float sensitivity;\r\n\r\n  void main() {\r\n    vUv = uv;\r\n    vec3 pos = position;\r\n\r\n    float actualDepth = depth * meshDepth;\r\n    float focusDepth = focus * meshDepth;\r\n\r\n    // Rotational displacement (relative to focus depth)\r\n    vec2 rotate = mouseDelta * sensitivity * \r\n        (1.0 - focus) * \r\n        (actualDepth - focusDepth) * \r\n        vec2(-1.0, 1.0);\r\n\r\n    // Calculate edge proximity factor (0 at edges, 1 in center)\r\n    float edgeWidth = 0.01; // controls edge stiffness\r\n    vec2 edgeFactorVec = smoothstep(0.0, edgeWidth, vUv) * \r\n                        smoothstep(1.0, 1.0 - edgeWidth, vUv);\r\n    float edgeFactor = edgeFactorVec.x * edgeFactorVec.y;\r\n\r\n    // Apply displacement with edge preservation\r\n    pos.xy += rotate * edgeFactor;\r\n\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n  }\r\n`;\r\n\r\nconst fragmentShader = `\r\n  uniform sampler2D u_image;\r\n  varying vec2 vUv;\r\n\r\n  void main() {\r\n    gl_FragColor = texture2D(u_image, vUv);\r\n  }\r\n`;\r\n\r\nconst WebGLViewer = ({ inputImage, depthMapImage, viewMode, mousePosition, orientation, parallaxStrength, focus, zoom }) => {\r\n  const canvasRef = useRef(null);\r\n  const rendererRef = useRef(null);\r\n  const sceneRef = useRef(null);\r\n  const cameraRef = useRef(null);\r\n  const materialRef = useRef(null);\r\n  const imageTextureRef = useRef(null);\r\n  const depthTextureRef = useRef(null);\r\n  const planeMeshRef = useRef(null);\r\n\r\n  const handleResize = useCallback(() => {\r\n    if (canvasRef.current && rendererRef.current && cameraRef.current && canvasRef.current.parentElement) {\r\n        const parentElement = canvasRef.current.parentElement;\r\n        const newWidth = parentElement.clientWidth;\r\n        const newHeight = parentElement.clientHeight;\r\n        rendererRef.current.setSize(newWidth, newHeight);\r\n        cameraRef.current.aspect = newWidth / newHeight;\r\n        cameraRef.current.updateProjectionMatrix();\r\n\r\n        // Recalculate mesh scale if planeMeshRef.current exists\r\n        if (planeMeshRef.current && imageTextureRef.current) {\r\n            const imageAspect = imageTextureRef.current.image.width / imageTextureRef.current.image.height;\r\n            const fov = cameraRef.current.fov;\r\n            const cameraZ = cameraRef.current.position.z;\r\n            const containerAspect = newWidth / newHeight;\r\n            const visibleHeight = 2 * Math.tan(THREE.MathUtils.degToRad(fov / 2)) * cameraZ;\r\n            const visibleWidth = visibleHeight * containerAspect;\r\n\r\n            let scale;\r\n            if (containerAspect > imageAspect) {\r\n                scale = visibleHeight / 1; // Geometry height is 1\r\n            } else {\r\n                scale = visibleWidth / imageAspect; // Geometry width is imageAspect\r\n            }\r\n            planeMeshRef.current.scale.set(scale, scale, 1);\r\n        }\r\n    }\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    // Initialize THREE.js scene\r\n    const canvas = canvasRef.current;\r\n    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });\r\n    renderer.setSize(canvas.clientWidth, canvas.clientHeight);\r\n    renderer.setPixelRatio(window.devicePixelRatio);\r\n    rendererRef.current = renderer;\r\n\r\n    const scene = new THREE.Scene();\r\n    sceneRef.current = scene;\r\n\r\n    const fov = 45;\r\n    const camera = new THREE.PerspectiveCamera(fov, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);\r\n    camera.position.z = 2;\r\n    cameraRef.current = camera;\r\n\r\n    const geometry = new THREE.PlaneGeometry(1, 1);\r\n    const material = new THREE.ShaderMaterial({\r\n      vertexShader,\r\n      fragmentShader,\r\n      uniforms: {\r\n        u_image: { value: null },\r\n        mouseDelta: { value: new THREE.Vector2(0, 0) },\r\n        focus: { value: focus },\r\n        meshDepth: { value: 1.0 },\r\n        sensitivity: { value: 0.5 }\r\n      },\r\n    });\r\n    materialRef.current = material;\r\n\r\n    // Plane will be created and added when depth map is ready\r\n    // const plane = new THREE.Mesh(geometry, material);\r\n    // scene.add(plane);\r\n\r\n    const animate = () => {\r\n      requestAnimationFrame(animate);\r\n      renderer.render(scene, camera);\r\n    };\r\n    animate();\r\n\r\n    window.addEventListener('resize', handleResize);\r\n    handleResize();\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', handleResize);\r\n      if (rendererRef.current) rendererRef.current.dispose();\r\n      if(imageTextureRef.current) imageTextureRef.current.dispose(); // Dispose textures on unmount\r\n      if(depthTextureRef.current) depthTextureRef.current.dispose(); // Dispose textures on unmount\r\n      // geometry.dispose(); material.dispose(); // If created here\r\n    };\r\n  }, [handleResize]);\r\n\r\n  useEffect(() => {\r\n    if (materialRef.current && inputImage) {\r\n      if (imageTextureRef.current) imageTextureRef.current.dispose();\r\n      const loader = new THREE.TextureLoader();\r\n      loader.load(inputImage, (texture) => {\r\n        imageTextureRef.current = texture;\r\n        materialRef.current.uniforms.u_image.value = texture;\r\n        // Resize logic will be handled when the mesh is created/updated\r\n      });\r\n    }\r\n  }, [inputImage]);\r\n\r\n  const createGeometryFromDepthMap = (depthData) => {\r\n    const width = depthData.width;\r\n    const height = depthData.height;\r\n    const imageAspect = width / height;\r\n    const geometry = new THREE.PlaneGeometry(imageAspect, 1, width - 1, height - 1);\r\n    const vertices = geometry.attributes.position.array;\r\n    const depths = new Float32Array(vertices.length / 3);\r\n\r\n    for (let i = 0; i < vertices.length; i += 3) {\r\n        const vertexIndex = i / 3;\r\n        const u = geometry.attributes.uv.array[vertexIndex * 2];\r\n        const v = 1.0 - geometry.attributes.uv.array[vertexIndex * 2 + 1];\r\n        const x = Math.floor(u * (width - 1));\r\n        const y = Math.floor(v * (height - 1));\r\n        const pixelIndex = (y * width + x) * 4;\r\n        const depthValue = depthData.data[pixelIndex] / 255.0;\r\n\r\n        vertices[i + 2] = depthValue; // Set z based on depth\r\n        depths[vertexIndex] = depthValue;\r\n    }\r\n\r\n    geometry.setAttribute('depth', new THREE.BufferAttribute(depths, 1));\r\n    geometry.attributes.position.needsUpdate = true;\r\n    return geometry;\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (planeMeshRef.current) {\r\n      sceneRef.current.remove(planeMeshRef.current);\r\n      planeMeshRef.current.geometry.dispose();\r\n      planeMeshRef.current = null;\r\n    }\r\n\r\n    if (materialRef.current && depthMapImage && sceneRef.current) {\r\n      const img = new Image();\r\n      img.src = depthMapImage;\r\n      img.onload = () => {\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = img.width;\r\n        canvas.height = img.height;\r\n        const ctx = canvas.getContext('2d');\r\n        ctx.drawImage(img, 0, 0);\r\n        const depthData = ctx.getImageData(0, 0, img.width, img.height);\r\n\r\n        const geometry = createGeometryFromDepthMap(depthData);\r\n\r\n        const mesh = new THREE.Mesh(geometry, materialRef.current);\r\n        planeMeshRef.current = mesh;\r\n\r\n        const fov = cameraRef.current.fov;\r\n        const cameraZ = cameraRef.current.position.z;\r\n        const containerAspect = canvasRef.current.clientWidth / canvasRef.current.clientHeight;\r\n        const imageAspect = img.width / img.height;\r\n        const visibleHeight = 2 * Math.tan(THREE.MathUtils.degToRad(fov / 2)) * cameraZ;\r\n        const visibleWidth = visibleHeight * containerAspect;\r\n\r\n        let scale;\r\n        if (containerAspect > imageAspect) {\r\n            scale = visibleHeight / 1; // Geometry height is 1\r\n        } else {\r\n            scale = visibleWidth / imageAspect; // Geometry width is imageAspect\r\n        }\r\n        mesh.scale.set(scale, scale, 1);\r\n\r\n        sceneRef.current.add(mesh);\r\n      };\r\n    }\r\n  }, [depthMapImage]);\r\n\r\n  useEffect(() => {\r\n    if (materialRef.current) {\r\n      let targetX = 0, targetY = 0;\r\n      if (viewMode === 'mouse' && mousePosition) {\r\n        targetX = (mousePosition.x * 2 - 1);\r\n        targetY = (mousePosition.y * 2 - 1);\r\n      } else if (viewMode === 'gyro' && orientation) {\r\n        targetX = (orientation.gamma / -30);\r\n        targetY = (orientation.beta / -60);\r\n      } else if (viewMode === 'gyroInverse' && orientation) {\r\n        targetX = (orientation.gamma / 30);\r\n        targetY = (orientation.beta / 60);\r\n      }\r\n      const easing = 0.05;\r\n      const currentDelta = materialRef.current.uniforms.mouseDelta.value;\r\n      currentDelta.x += (targetX - currentDelta.x) * easing;\r\n      currentDelta.y += (targetY - currentDelta.y) * easing;\r\n    }\r\n  }, [mousePosition, orientation, viewMode]);\r\n\r\n  useEffect(() => {\r\n    if (materialRef.current) {\r\n      materialRef.current.uniforms.focus.value = focus;\r\n    }\r\n  }, [focus]);\r\n\r\n  useEffect(() => {\r\n    if (materialRef.current) {\r\n      materialRef.current.uniforms.sensitivity.value = parallaxStrength * 10; // Map strength to sensitivity\r\n    }\r\n  }, [parallaxStrength]);\r\n\r\n  useEffect(() => {\r\n    if (cameraRef.current) {\r\n      cameraRef.current.position.z = 2 / zoom; // Adjust camera Z based on zoom\r\n      cameraRef.current.updateProjectionMatrix();\r\n    }\r\n  }, [zoom]);\r\n\r\n  return <canvas ref={canvasRef} className=\"main-view-canvas\"></canvas>;\r\n};\r\n\r\nfunction App() {\r\n  const inferenceWorkerRef = useRef(null); // Use useRef to hold the worker instance\r\n  const [inputSource, setInputSource] = useState(\"\");\r\n  const [depthMapSource, setDepthMapSource] = useState(null);\r\n  const [isDepthMapReady, setIsDepthMapReady] = useState(false);\r\n  const inputRef = useRef(null);\r\n  const outputRef = useRef(null);\r\n  const [processing, setProcessing] = useState(false);\r\n  const [isModelLoaded, setIsModelLoaded] = useState(false); // 添加模型加载状态\r\n  const isMobileDevice = () => {\r\n    return /Mobi|Android/i.test(navigator.userAgent);\r\n  };\r\n\r\n  const [viewMode, setViewMode] = useState(isMobileDevice() ? 'gyro' : 'mouse');\r\n  const [mousePositionForShader, setMousePositionForShader] = useState({ x: 0.5, y: 0.5 });\r\n  const [orientationForShader, setOrientationForShader] = useState(null);\r\n  const webGLContainerRef = useRef(null);\r\n  const [isGyroAvailable, setIsGyroAvailable] = useState(false);\r\n  const [parallaxStrength, setParallaxStrength] = useState(0.025);\r\n  const [focus, setFocus] = useState(0.75);\r\n  const [isDrawerOpen, setIsDrawerOpen] = useState(false);\r\n  const [zoom, setZoom] = useState(0.9); // New zoom state\r\n  const [currentModel, setCurrentModel] = useState('depthAnything'); // Add currentModel state\r\n  const [startX, setStartX] = useState(0); // For swipe to close drawer\r\n\r\n  useEffect(() => {\r\n    inferenceWorkerRef.current = new InferenceWorker(); // Initialize worker in useEffect\r\n    // 检查模型加载状态\r\n    const checkModelLoaded = async () => {\r\n      try {\r\n        // 调用worker的isModelLoaded方法检查模型是否加载完成\r\n        const isLoaded = await inferenceWorkerRef.current.isModelLoaded(currentModel);\r\n        setIsModelLoaded(isLoaded);\r\n        if (!isLoaded) {\r\n          // 如果模型未加载完成，每秒检查一次\r\n          setTimeout(checkModelLoaded, 1000);\r\n        }\r\n      } catch (err) {\r\n        console.error(\"Error checking model loaded status:\", err);\r\n        setTimeout(checkModelLoaded, 1000);\r\n      }\r\n    };\r\n    \r\n    checkModelLoaded();\r\n    // Optional: Add cleanup for the worker if workerize-loader provides a terminate method\r\n    // return () => { if (inferenceWorkerRef.current?.terminate) inferenceWorkerRef.current.terminate(); };\r\n  }, []); // Empty dependency array ensures this runs only once on mount\r\n\r\n  useEffect(() => {\r\n    if (inferenceWorkerRef.current) {\r\n      setIsModelLoaded(false); // 切换模型时重置加载状态\r\n      inferenceWorkerRef.current.switchModel(currentModel)\r\n        .then(success => {\r\n          if (success) {\r\n            // 检查模型加载状态\r\n            const checkModelLoaded = async () => {\r\n              try {\r\n                const isLoaded = await inferenceWorkerRef.current.isModelLoaded(currentModel);\r\n                setIsModelLoaded(isLoaded);\r\n                if (!isLoaded) {\r\n                  setTimeout(checkModelLoaded, 1000);\r\n                } else if (inputSource && !processing) {\r\n                  // 模型加载完成且有输入图像时，重新运行推理\r\n                  inferCallback();\r\n                }\r\n              } catch (err) {\r\n                console.error(\"Error checking model loaded status:\", err);\r\n                setTimeout(checkModelLoaded, 1000);\r\n              }\r\n            };\r\n            checkModelLoaded();\r\n          }\r\n        });\r\n    }\r\n  }, [currentModel]); // Switch model in worker when currentModel changes\r\n\r\n  useEffect(() => {\r\n    if (window.DeviceOrientationEvent) {\r\n      setIsGyroAvailable(true);\r\n      const handleDeviceOrientation = (event) => {\r\n        if (viewMode === 'gyro' || viewMode === 'gyroInverse') {\r\n          setOrientationForShader({\r\n            alpha: event.alpha, // Z axis rotation\r\n            beta: event.beta,   // X axis rotation (front to back tilt)\r\n            gamma: event.gamma, // Y axis rotation (side to side tilt)\r\n          });\r\n        }\r\n      };\r\n      window.addEventListener('deviceorientation', handleDeviceOrientation);\r\n      return () => {\r\n        window.removeEventListener('deviceorientation', handleDeviceOrientation);\r\n      };\r\n    } else {\r\n      setIsGyroAvailable(false);\r\n    }\r\n  }, [viewMode]); // Rerun if viewMode changes to attach/detach listener\r\n\r\n  const inferCallback = useCallback(async () => { // Made the callback async directly\r\n    if (!inferenceWorkerRef.current) {\r\n      console.error(\"Inference worker is not initialized yet.\");\r\n      alert(\"Worker not ready, please try again shortly.\");\r\n      return;\r\n    }\r\n    \r\n    // 检查模型是否已加载\r\n    if (!isModelLoaded) {\r\n      console.error(\"Model is not loaded yet.\");\r\n      alert(\"模型尚未加载完成，请稍后再试。\");\r\n      return;\r\n    }\r\n    \r\n    // Ensure inputRef.current is available and has a valid src and dimensions before processing\r\n    if (processing || !inputRef.current || !inputRef.current.src || inputRef.current.src === \"\" || inputRef.current.naturalWidth === 0 || inputRef.current.naturalHeight === 0) {\r\n      return;\r\n    }\r\n    setProcessing(true);\r\n    // Clear previous depth map on canvas before new inference\r\n    if (outputRef.current) {\r\n        const ctx = outputRef.current.getContext('2d');\r\n        ctx.clearRect(0, 0, outputRef.current.width, outputRef.current.height);\r\n    }\r\n    setDepthMapSource(null); // Explicitly clear depth map source for WebGLViewer\r\n    setIsDepthMapReady(false); // Set depth map not ready\r\n\r\n    try {\r\n      // 获取原始图像尺寸\r\n      const originalHeight = inputRef.current.naturalHeight;\r\n      const originalWidth = inputRef.current.naturalWidth;\r\n      \r\n      // 检查图像尺寸是否超过WebGL限制(4096x4096)\r\n      const MAX_TEXTURE_SIZE = 4096;\r\n      let scaledHeight = originalHeight;\r\n      let scaledWidth = originalWidth;\r\n      \r\n      // 如果图像尺寸超过限制，按比例缩小\r\n      if (originalHeight > MAX_TEXTURE_SIZE || originalWidth > MAX_TEXTURE_SIZE) {\r\n        const aspectRatio = originalWidth / originalHeight;\r\n        if (originalHeight > originalWidth) {\r\n          scaledHeight = MAX_TEXTURE_SIZE;\r\n          scaledWidth = Math.floor(scaledHeight * aspectRatio);\r\n          if (scaledWidth > MAX_TEXTURE_SIZE) {\r\n            scaledWidth = MAX_TEXTURE_SIZE;\r\n            scaledHeight = Math.floor(scaledWidth / aspectRatio);\r\n          }\r\n        } else {\r\n          scaledWidth = MAX_TEXTURE_SIZE;\r\n          scaledHeight = Math.floor(scaledWidth / aspectRatio);\r\n          if (scaledHeight > MAX_TEXTURE_SIZE) {\r\n            scaledHeight = MAX_TEXTURE_SIZE;\r\n            scaledWidth = Math.floor(scaledHeight * aspectRatio);\r\n          }\r\n        }\r\n        console.log(`图像尺寸(${originalWidth}x${originalHeight})超过WebGL限制，已调整为${scaledWidth}x${scaledHeight}`);\r\n      }\r\n      \r\n      // 创建一个临时canvas来调整图像尺寸\r\n      const tempCanvas = document.createElement('canvas');\r\n      tempCanvas.width = scaledWidth;\r\n      tempCanvas.height = scaledHeight;\r\n      const ctx = tempCanvas.getContext('2d');\r\n      ctx.drawImage(inputRef.current, 0, 0, scaledWidth, scaledHeight);\r\n      \r\n      // 从调整后的canvas创建tensor\r\n      let input = tf.browser.fromPixels(tempCanvas);\r\n      const originalSize = [scaledHeight, scaledWidth];\r\n      // Ensure input has 3 channels for resizeBilinear\r\n      if (input.shape[2] === 4) {\r\n        input = input.slice([0, 0, 0], [input.shape[0], input.shape[1], 3]);\r\n      }\r\n      \r\n      const inputSerialized = serializeTensor(input);\r\n      input.dispose(); \r\n\r\n      let outputTensor = deserializeTensor(\r\n        await inferenceWorkerRef.current.infer(inputSerialized) // Use worker from ref\r\n      );\r\n      outputTensor = tf.image.resizeBilinear(outputTensor, originalSize);\r\n      \r\n      // Draw to outputRef (2D canvas preview)\r\n      if (outputRef.current) {\r\n        outputRef.current.width = originalSize[1];\r\n        outputRef.current.height = originalSize[0];\r\n        await tf.browser.toPixels(outputTensor, outputRef.current);\r\n      }\r\n      \r\n      // Create data URL for WebGLViewer\r\n      const depthMapCanvas = document.createElement('canvas');\r\n      depthMapCanvas.width = originalSize[1];\r\n      depthMapCanvas.height = originalSize[0];\r\n      await tf.browser.toPixels(outputTensor.clone(), depthMapCanvas); // Clone tensor before using for toDataURL if needed elsewhere\r\n      setDepthMapSource(depthMapCanvas.toDataURL());\r\n      setIsDepthMapReady(true);\r\n      \r\n      outputTensor.dispose();\r\n\r\n    } catch (err) {\r\n      console.error(\"Inference error:\", err);\r\n      \r\n      // 提供更具体的错误信息\r\n      if (err.message && err.message.includes(\"Requested texture size\")) {\r\n        alert(\"图像尺寸过大，已自动调整。请重试或选择较小的图片。\");\r\n      } else {\r\n        alert(\"推理过程中发生错误，请重试或选择其他图片。\");\r\n      }\r\n    } finally {\r\n      setProcessing(false); \r\n    }\r\n  }, [processing, inputRef, outputRef, setDepthMapSource, setProcessing, currentModel, isModelLoaded]); // Added isModelLoaded to deps\r\n\r\n  const onDrop = useCallback(\r\n    (acceptedFiles) => {\r\n      if (processing || !isModelLoaded) {\r\n        return;\r\n      }\r\n      const fr = new FileReader();\r\n      fr.onload = () => {\r\n        setInputSource(fr.result); // This will trigger img.onLoad, which calls inferCallback\r\n        // Clearing depthMapSource here is good, inferCallback will also clear its canvas part\r\n        setDepthMapSource(null);\r\n        setIsDepthMapReady(false);\r\n        if (outputRef.current) { // Clear the 2D preview canvas as well\r\n            const ctx = outputRef.current.getContext('2d');\r\n            if (outputRef.current.width > 0 && outputRef.current.height > 0) {\r\n                 ctx.clearRect(0, 0, outputRef.current.width, outputRef.current.height);\r\n            }\r\n        }\r\n      };\r\n      fr.readAsDataURL(acceptedFiles[0]);\r\n    },\r\n    [setInputSource, setDepthMapSource, processing, outputRef, isModelLoaded] // Added isModelLoaded\r\n  );\r\n  const { getRootProps, getInputProps, isDragActive } = useDropzone({\r\n    onDrop,\r\n    accept: \"image/*\",\r\n  });\r\n\r\n  const handleMouseMoveInViewer = (event) => {\r\n    if (viewMode === 'mouse' && webGLContainerRef.current) {\r\n      const rect = webGLContainerRef.current.getBoundingClientRect();\r\n      const clientX = event.touches ? event.touches[0].clientX : event.clientX;\r\n      const clientY = event.touches ? event.touches[0].clientY : event.clientY;\r\n      const x = (clientX - rect.left) / rect.width;\r\n      const y = (clientY - rect.top) / rect.height;\r\n      setMousePositionForShader({ x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, 1.0 - y)) });\r\n    }\r\n  };\r\n\r\n  const toggleDrawer = () => {\r\n    setIsDrawerOpen(!isDrawerOpen);\r\n  };\r\n\r\n  const handleTouchStart = (e) => {\r\n    setStartX(e.touches[0].clientX);\r\n  };\r\n\r\n  const handleTouchMove = (e) => {\r\n    if (isDrawerOpen) {\r\n      const currentX = e.touches[0].clientX;\r\n      const diffX = currentX - startX;\r\n      // If swiping left significantly, close the drawer\r\n      if (diffX < -50) { // Threshold of 50 pixels\r\n        setIsDrawerOpen(false);\r\n      }\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"app-container\">\r\n      <button className=\"hamburger-menu\" onClick={toggleDrawer}>\r\n        <span></span>\r\n        <span></span>\r\n        <span></span>\r\n      </button>\r\n      {isDrawerOpen && <div className=\"overlay\" onClick={toggleDrawer}></div>}\r\n      <aside\r\n        className={`sidebar ${isDrawerOpen ? 'sidebar--open' : ''}`}\r\n        onTouchStart={handleTouchStart}\r\n        onTouchMove={handleTouchMove}\r\n      >\r\n        <h2>控制台</h2>\r\n        <div className=\"control-group\">\r\n          <label htmlFor=\"modelSelect\">选择模型</label>\r\n          <select id=\"modelSelect\" value={currentModel} onChange={(e) => setCurrentModel(e.target.value)}>\r\n            <option value=\"depthAnything\">DepthAnything</option>\r\n            <option value=\"midas\">Midas</option>\r\n          </select>\r\n\r\n          <label htmlFor=\"viewModeSelect\">控制模式</label>\r\n          <select id=\"viewModeSelect\" value={viewMode} onChange={(e) => setViewMode(e.target.value)}>\r\n            <option value=\"mouse\">鼠标</option>\r\n            {isGyroAvailable && <option value=\"gyro\">陀螺仪</option>}\r\n            {isGyroAvailable && <option value=\"gyroInverse\">陀螺仪(反向)</option>}\r\n          </select>\r\n          {!isGyroAvailable && (viewMode === 'gyro' || viewMode === 'gyroInverse') && <p style={{color: 'orange'}}>陀螺仪不可用或不支持。</p>}\r\n        </div>\r\n        \r\n        <div className=\"control-group\">\r\n          <label htmlFor=\"parallaxStrengthRange\">位移强度: {parallaxStrength.toFixed(3)}</label>\r\n          <input \r\n              type=\"range\" \r\n              id=\"parallaxStrengthRange\" \r\n              min=\"0.001\" \r\n              max=\"0.1\" \r\n              step=\"0.001\" \r\n              value={parallaxStrength} \r\n              onChange={(e) => setParallaxStrength(parseFloat(e.target.value))} \r\n              onTouchMove={(e) => e.stopPropagation()} // Prevent sidebar from closing when sliding\r\n            />\r\n        </div>\r\n\r\n        <div className=\"control-group\">\r\n          <label htmlFor=\"focusRange\">焦点: {focus.toFixed(2)}</label>\r\n          <input \r\n              type=\"range\" \r\n              id=\"focusRange\" \r\n              min=\"0.0\" \r\n              max=\"1.0\" \r\n              step=\"0.01\" \r\n              value={focus} \r\n              onChange={(e) => setFocus(parseFloat(e.target.value))} \r\n              onTouchMove={(e) => e.stopPropagation()} // Prevent sidebar from closing when sliding\r\n            />\r\n        </div>\r\n\r\n        <div className=\"image-preview-area\">\r\n            <h3>原始图像</h3>\r\n            <div \r\n              className={[\r\n                \"image-dropzone\",\r\n                !isModelLoaded\r\n                  ? \"image-dropzone--disabled\"\r\n                  : isDragActive\r\n                    ? \"image-dropzone--highlight\"\r\n                    : \"image-dropzone--default\",\r\n              ].join(\" \")}\r\n              {...(isModelLoaded ? getRootProps() : {})}\r\n            >\r\n              {isModelLoaded && <input {...getInputProps()} />}\r\n              {inputSource ? (\r\n                <img ref={inputRef} alt=\"Input\" src={inputSource} className=\"preview-image\" onLoad={isModelLoaded ? inferCallback : undefined} />\r\n              ) : (\r\n                <p>{!isModelLoaded ? \"模型加载中...\" : \"点击上传，或拖拽图片至此处\"}</p>\r\n              )}\r\n            </div>\r\n        </div>\r\n\r\n        <div className=\"image-preview-area\">\r\n            <h3>深度图</h3>\r\n            <canvas ref={outputRef} className=\"preview-image\"></canvas>\r\n        </div>\r\n        \r\n        <button onClick={inferCallback} disabled={processing || !inputSource || !isModelLoaded}>\r\n          {processing ? \"生成中...\" : !isModelLoaded ? \"模型加载中...\" : \"生成深度图\"}\r\n        </button>\r\n        <div className=\"made-by-text\">\r\n          Made by J\r\n        </div>\r\n      </aside>\r\n      <main\r\n        className=\"main-content\"\r\n        onMouseMove={handleMouseMoveInViewer}\r\n        onTouchMove={handleMouseMoveInViewer}\r\n        ref={webGLContainerRef}\r\n      >\r\n        <h1 className=\"main-title\">单目深度图估算</h1>\r\n        <div className=\"webgl-viewer-container\">\r\n          {processing && !isDepthMapReady && (\r\n            <div className=\"loading-overlay\">\r\n              <p>生成中...</p>\r\n            </div>\r\n          )}\r\n          <WebGLViewer \r\n            inputImage={inputSource} \r\n            depthMapImage={isDepthMapReady ? depthMapSource : null} \r\n            viewMode={viewMode} \r\n            mousePosition={mousePositionForShader}\r\n            orientation={orientationForShader}\r\n            parallaxStrength={parallaxStrength}\r\n            focus={focus}\r\n            zoom={zoom} />\r\n          <div className=\"viewer-controls\">\r\n            <button onClick={() => {\r\n              setZoom(0.9)\r\n              setMousePositionForShader({ x: 0.5, y: 0.5 });\r\n            }}>重置</button>\r\n            <label htmlFor=\"zoomRange\">{zoom.toFixed(2)}x</label>\r\n            <input \r\n              type=\"range\" \r\n              id=\"zoomRange\" \r\n              min=\"0.1\" \r\n              max=\"1.5\" \r\n              step=\"0.1\" \r\n              value={zoom} \r\n              onChange={(e) => setZoom(parseFloat(e.target.value))} \r\n            />\r\n          </div>\r\n        </div>\r\n      </main>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}